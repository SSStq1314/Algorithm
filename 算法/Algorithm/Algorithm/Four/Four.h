//
//  Four.h
//  Algorithm
//
//  Created by taoxiaofei on 2018/12/29.
//  Copyright © 2018年 easy. All rights reserved.
//  在给定的成对整数数组中，请找出所有总和等于给定数字的组合

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface Four : NSObject

@end

NS_ASSUME_NONNULL_END

/*
 解法一：穷举法
 最直观的想法就是穷举，把数组中元素的所有组合情况都找出来，然后看看哪些组合满足给定的和即可，这种方法的计算量非常大，是指数级的，假设数组有n个元素，那么所有组合的情况一共有2 ^ n种（包括空集），如果n很大的话，这个方法将会非常慢。那么如何找出所有这些组合呢？其实对于任意一个组合来讲，数组a中任意一个元素要么在这个组合中，要么不在这个组合中，我们用1表示在，用0表示不在，那么每一种组合实际上对应着一个01序列，而这个序列对应着一个十进制数，一共有多少种这样的序列呢？前面说了，是2 ^ n种，分别对应1 - 2 ^ n中的每一个十进制数，所以我们只需遍历这些数字，确定哪些位是1，将数组a中对应的数字放入组合中，再检查一下这个组合的和是否为sum即可。举个例子，在题目描述中我们说到a[6] = { 1, 2, 3, 4, 5, 6 }，sum = 10，那么
 
 {1, 2, 3, 4} 相当于 111100 （1, 2, 3, 4在组合中，而5, 6不在）
 
 {1, 3, 6} 相当于101001
 
 ...
 
 数组a有6个元素，所以我们要搜索64个数，只有上面的三种组合满足条件，其他的全部淘汰。
 
 解法二：回溯法
 很多数排列组合问题都可以用回溯法来解决，回溯相比上面方法的优点就是减少可行解搜索的范围，因为回溯一旦发现当前解不满足条件就会停止搜索，回溯并进入下一个分支进行搜索，比上面的方法快很多，这里使用的是回溯法中的子集树模型。对于数组中任意一个元素，先将其放入结果集中，如果当前和不超出给定和，那就继续考察下一个元素，如果超出给定和，则舍弃当前元素。如此往复，直到找到所有可行解。
 
 首先定义一个标志位数组flag[]，flag[i]如果为true，则表示a[i]在当前解中，如果flag[i]为false则表示不在。这个数组元素个数与数组a的元素个数相同。
 */
